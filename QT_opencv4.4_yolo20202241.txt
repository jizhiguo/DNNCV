#include<opencv2\opencv.hpp>
#include<opencv2\dnn.hpp>
#include <opencv2\imgproc\types_c.h> 

#include "global.h"
#include "ImageBuffer.h"
#include "MatToQImage.h"
#include "qDebug.h"

void ProcessingThread::run()
{
//1\
    初始化DARKNET
    //opencv:: yolo net ini
    cv::String cfg = "D:\\Server_Project\\model\\yolov4.cfg";
    cv::String weight = "D:\\Server_Project\\model\\yolov4.weights";
    //模型读入
    cv::dnn::Net net = cv::dnn::readNetFromDarknet(cfg, weight);
    std::string  names_file_ = "D:\\Server_Project\\model\\coco.names";
    std::vector<std::string> obj_names = objects_names_from_file(names_file_);
    
    //-------------------------模型设置----------------------
    net.setPreferableBackend(cv::dnn::Backend::DNN_BACKEND_CUDA);
    net.setPreferableTarget(cv::dnn::Target::DNN_TARGET_CUDA);


//2\输入：80类可选配置文件读入；{{id,bool},{bool,id},{bool,id,classname}...}
   备注：对话框配置来配置上述配置文件。目的是提供配置界面来配置这边的读入配置文件。
//3\输入：各个雷达的多变行QLIST向量组合；{{CAMERAID,[PONT1,PONT2,PONT3,PON4]},{CAMERAID,[PONT1,PONT2,PONT3,PON4]}，。。。16个}
//   备注：

//
	QString cocofile="D:\\coconames.txt";
	QString polyfile ="D:\\polygons.txt";
	Coconames coconames；
	DevPolygons polygons；
	coconames.loadCoconames(cocofile);
	polygons.loadPolygons(polyfile);
	std::vector<cv::Rect> out_Boxes,
	std::vector<int> out_ClassIds,
	std::vector<float> out_Confidences,
	std::vector<cv::String> out_ClassNames)
//
    qDebug() << "CV::NET int finished!";
    while(1)
    {
        /////////////////////////////////
        // Stop thread if stopped=TRUE //测试是否停止的过程要加锁
        /////////////////////////////////
        //qDebug() << "ProcessingThread Enter while(1) loop! stoppedMutex1.lock";
        stoppedMutex1.lock();
        if (stopped1)
        {
            stopped1=false;
            stoppedMutex1.unlock();
            break;
        }
        stoppedMutex1.unlock();
        /////////////////////////////////
        /*qDebug() << "ProcessingThread Enter while(1) loop! stoppedMutex1.unlock";*/
        // Get frame from queue, store in currentFrame, set ROI
        //if (!imageBuffer->isEmpty()) {

        
        //currentFrame= cv::Mat(imageBuffer->getFrame());//从缓冲区中取出一帧
        {info:CAMERAID,image}
        currentFrame=imread("D:\\Server_Project\\image\\dog.jpg");
        //mqttMsgBuffer->addMqttMsg("finshed");        
        //---------------------------opencv yolo4 start
        updateMembersMutex.lock();
        //以下的函数或者程序可以用来对每一帧图像进行处理
        
        //---------------------------------------开始检测---------------------------------------
            //开始时间
        auto start = std::chrono::steady_clock::now();
        cv::Mat inputBlob = cv::dnn::blobFromImage(currentFrame, 1.0 / 255, cv::Size(608, 608), cv::Scalar());
        net.setInput(inputBlob);
        ////获取未连接输出层
        std::vector<cv::String> outNames = net.getUnconnectedOutLayersNames();
        //for (int i = 0; i < outNames.size(); i++) {
        //    qDebug() << "output layer name : " << outNames[i].c_str();
        //}
        //读取时间1
        auto end2 = std::chrono::steady_clock::now();
        std::chrono::duration<double> spent2 = end2 - start;
        //qDebug() << " Time: " << spent2.count() << " sec \n";
        std::vector<cv::Mat> outs;
        net.forward(outs, outNames);
        //网络检测时间
        auto end3 = std::chrono::steady_clock::now();
        std::chrono::duration<double> spent3 = end3 - start;
        //qDebug() << " Time: " << spent3.count() << " sec \n";
       //----------------------处理输出结果-------------------------
       //需要的变量
        float* data;
        cv::Mat scores;
        std::vector<cv::Rect> boxes;
        std::vector<int> classIds;
        std::vector<float> confidences;
        int centerX, centerY, width, height, left, top;
        float confidenceThreshold = 0.2;
        double confidence;
        cv::Point classIdPoint;
        //找出所有的目标及其位置
        for (size_t i = 0; i < outs.size(); ++i) {
            data = (float*)outs[i].data;
            for (int j = 0; j < outs[i].rows; ++j, data += outs[i].cols) {
                scores = outs[i].row(j).colRange(5, outs[i].cols);
                minMaxLoc(scores, 0, &confidence, 0, &classIdPoint);
                if (confidence > confidenceThreshold) {
                    centerX = (int)(data[0] * currentFrame.cols);
                    centerY = (int)(data[1] * currentFrame.rows);
                    width = (int)(data[2] * currentFrame.cols);
                    height = (int)(data[3] * currentFrame.rows);
                    left = centerX - width / 2;
                    top = centerY - height / 2;
                    classIds.push_back(classIdPoint.x);
                    confidences.push_back((float)confidence);
                    boxes.push_back(cv::Rect(left, top, width, height));
                }
            }
        }
        std::vector<int> indices;
        cv::dnn::NMSBoxes(boxes, confidences, 0.3, 0.2, indices);
        //-----------------将预测框和内容显示输出到图像---------
        cv::Scalar rectColor, textColor; //box 和 text 的颜色
        cv::Rect box, textBox;
        int idx;
        cv::String className;
        cv::Size labelSize;
        for (size_t i = 0; i < indices.size(); ++i) {
            idx = indices[i];
            //className = classNamesVec[classIds[idx]];
            className = obj_names[classIds[idx]];
            labelSize = cv::getTextSize(className, cv::HersheyFonts::FONT_HERSHEY_SIMPLEX, 0.5, 1, 0);
            box = boxes[idx];
            textBox = cv::Rect(cv::Point(box.x - 1, box.y),
                cv::Point(box.x + labelSize.width, box.y - labelSize.height));
            rectColor = cv::Scalar(idx * 11 % 256, idx * 22 % 256, idx * 33 % 256);
            textColor = cv::Scalar(255 - idx * 11 % 256, 255 - idx * 22 % 256, 255 - idx * 33 % 256);

            //图片的关注点：不是安防区内的目标，不画框和文字。
            1）判断是否在多边形内。
            2）判断是否是需要配置识别的类别。

//
	if (polygons.inPolygons(box.x ,box.y)&&coconames.inCoconames(idx ))
	{
		out_Boxes.push_back(box);
		out_ClassIds.push_back(classIds[idx]);
		out_Confidences.push_back(confidences[idx]);
		out_ClassNames.push_back(className);
		rectangle(currentFrame, box, rectColor, 2, 8, 0);
		rectangle(currentFrame, textBox, rectColor, -1, 8, 0);
		putText(currentFrame, className.c_str(), cv::Point(box.x, box.y - 2), cv::HersheyFonts::FONT_HERSHEY_SIMPLEX, 0.5, textColor, 1, 8);
	}
//
//            rectangle(currentFrame, box, rectColor, 2, 8, 0);
//            rectangle(currentFrame, textBox, rectColor, -1, 8, 0);
   //         putText(currentFrame, className.c_str(), cv::Point(box.x, box.y - 2), cv::HersheyFonts::FONT_HERSHEY_SIMPLEX, 0.5, textColor, 1, 8);
        }
        //输出目标框框的全部时间
        auto end = std::chrono::steady_clock::now();
        std::chrono::duration<double> spent = end - start;
        //qDebug() << " Time: " << spent.count() << " sec \n";
        qRound(spent.count());
        std::string fps_str = "AllTime:" + std::to_string(spent.count()) + ", ReadTime: " + std::to_string(spent2.count()) + ", DrawTime: " + std::to_string(spent3.count());
        putText(currentFrame, fps_str, cv::Point2f(10, 20), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 255), 1);
        imshow("【OpenCV - YOLO】", currentFrame);
        //frame=MatToQImage(currentFrame);
        //this->setCVMat2QtLabel(this->inputImage, this->imageLabel);
//4 输出  字符串输出【1、图片的BASE64,2、防区内的识别目标信息：类别，数量】
//
	QString output=coconames.formatedOutput(currentFrame，out_Boxes，out_ClassIds，out_Confidences，out_ClassNames);
//

        /*MqttClientSender::Instance()->publish("image", "processfinished.");*/
        //updateMembersMutex.unlock();
        // Convert Mat to QImage: Show BGR frame
        //----------------------------opencv yolo4 end
        // Update statistics
        //currentSizeOfBuffer=imageBuffer->getSizeOfImageBuffer();
        // Inform GUI thread of new frame (QImage)
        //发出信号，通知GUI线程有新处理好的一帧
        //emit newFrame(frame);
        //qDebug() << "Processing 1 frame finished!";
       }
    }
    //qDebug() << "Stopping processing thread...";
    
}

    QString name;
    cv::Mat currentFrame;
    cv::Mat currentFrameGrayscale;
    std::vector<std::string> objects_names_from_file(std::string const filename);
std::vector<std::string> ProcessingThread::objects_names_from_file(std::string const filename)
{
    std::ifstream file(filename);
    std::vector<std::string> file_lines;
    if (!file.is_open()) return file_lines;
    for (std::string line; getline(file, line);) file_lines.push_back(line);
    std::cout << "object names loaded \n";
    return file_lines;
}
